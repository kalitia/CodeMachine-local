import { readFile, writeFile, mkdir, stat } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import * as path from 'node:path';
import { createRequire } from 'node:module';

const require = createRequire(import.meta.url);

export type AgentsBuilderOptions = {
  workingDir: string; // project root where .codemachine lives
  force?: boolean; // overwrite generated files if true
  specPath?: string; // runner spec path for tasks extraction
};

type AgentInput = {
  id?: string;
  name?: string;
  promptPath?: string;
  description?: string;
  [key: string]: unknown;
};

function slugify(value: string): string {
  return value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '');
}

async function ensureDir(dirPath: string): Promise<void> {
  await mkdir(dirPath, { recursive: true });
}

async function readOptional(filePath: string): Promise<string | undefined> {
  try {
    return await readFile(filePath, 'utf8');
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') return undefined;
    throw error;
  }
}

async function writeIfNeeded(filePath: string, content: string, force?: boolean): Promise<boolean> {
  if (!force) {
    try {
      const existing = await readFile(filePath, 'utf8');
      if (existing === content) return false; // unchanged
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') throw error;
    }
  }
  await writeFile(filePath, content, 'utf8');
  return true;
}

function resolveAgentsModule(projectRoot: string): string | undefined {
  const candidates = [
    path.join(projectRoot, 'inputs', 'agents.cjs'),
    path.join(projectRoot, 'inputs', 'agents.js'),
  ];
  return candidates.find((p) => existsSync(p));
}

function loadAgents(projectRoot: string): AgentInput[] {
  const modPath = resolveAgentsModule(projectRoot);
  if (!modPath) return [];
  try {
    delete require.cache[require.resolve(modPath)];
  } catch {}
  const mod = require(modPath);
  return Array.isArray(mod) ? (mod as AgentInput[]) : [];
}

async function materializeAgentPrompt(
  projectRoot: string,
  agent: AgentInput,
  opts: { force?: boolean; specPath?: string },
): Promise<string | undefined> {
  const idOrName = agent.id || agent.name;
  if (!idOrName) return undefined;
  const fileName = `${slugify(String(idOrName))}.md`;
  const targetDir = path.join(projectRoot, '.codemachine', 'agents');
  const targetPath = path.join(targetDir, fileName);
  await ensureDir(targetDir);

  // Base content from global prompt if available
  let baseContent = '';
  if (agent.promptPath && typeof agent.promptPath === 'string') {
    const maybe = await readOptional(agent.promptPath);
    baseContent = maybe ?? '';
  }

  const header = `<!-- Generated by agents-builder; edit project-specific sections. -->\n`;
  const lead = `# ${agent.name || agent.id}\n\n`;
  const desc = agent.description ? `${agent.description}\n\n` : '';
  const projectSection = `## Project-Specific Instructions\n\n- TODO: specialize this agent for the project.\n- Source spec: ${opts.specPath ?? 'N/A'}\n`;

  const content = [header, lead, desc, baseContent, '\n', projectSection].join('');
  await writeIfNeeded(targetPath, content, opts.force);
  return targetPath;
}

async function writeTasksJson(
  projectRoot: string,
  opts: { force?: boolean; specPath?: string },
): Promise<string> {
  const planDir = path.join(projectRoot, '.codemachine', 'plan');
  await ensureDir(planDir);
  const tasksPath = path.join(planDir, 'tasks.json');

  // If tasks already exist and not forcing, preserve as-is to ensure idempotence
  if (!opts.force && existsSync(tasksPath)) {
    return tasksPath;
  }

  // Minimal, non-empty placeholder with hooks for future extraction from spec
  const payload = {
    meta: {
      generatedAt: new Date().toISOString(),
      specPath: opts.specPath ?? null,
      note: 'TODO: extract tasks from runner-prompts/user-input.md',
    },
    tasks: [
      {
        id: 'T0',
        name: 'Initialize planning',
        details: 'Placeholder task; real tasks parsed from spec.',
        acceptanceCriteria: 'File exists and is non-empty',
        phase: 'Planning',
        done: false,
      },
    ],
  } as const;

  const content = `${JSON.stringify(payload, null, 2)}\n`;
  await writeIfNeeded(tasksPath, content, opts.force);
  return tasksPath;
}

export async function runAgentsBuilder(options: AgentsBuilderOptions): Promise<void> {
  const projectRoot = options.workingDir || process.cwd();

  // Ensure base structure exists (agents/ and plan/) â€” workspace bootstrap already does this
  await ensureDir(path.join(projectRoot, '.codemachine', 'agents'));
  await ensureDir(path.join(projectRoot, '.codemachine', 'plan'));

  const agents = loadAgents(projectRoot);
  if (agents.length === 0) {
    console.log('agents-builder: No agents defined in inputs/agents.{js,cjs}; skipping prompt generation.');
  }

  // Generate per-agent prompts
  for (const agent of agents) {
    await materializeAgentPrompt(projectRoot, agent, {
      force: options.force,
      specPath: options.specPath,
    });
  }

  // Generate tasks.json (non-empty placeholder)
  await writeTasksJson(projectRoot, { force: options.force, specPath: options.specPath });

  // Basic visibility for operators
  const agentsDir = path.join(projectRoot, '.codemachine', 'agents');
  const planTasks = path.join(projectRoot, '.codemachine', 'plan', 'tasks.json');
  try {
    const tasksStat = await stat(planTasks);
    console.log(
      `agents-builder: wrote ${agents.length} agent prompt(s) to ${agentsDir} and plan/tasks.json (${tasksStat.size} bytes).`,
    );
  } catch {
    console.log(`agents-builder: wrote ${agents.length} agent prompt(s) to ${agentsDir}.`);
  }
}
